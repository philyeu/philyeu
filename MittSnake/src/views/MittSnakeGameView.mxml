<?xml version="1.0" encoding="utf-8"?>
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"
		xmlns:s="library://ns.adobe.com/flex/spark"
		xmlns:shapes="shapes.*"
		xmlns:mx="library://ns.adobe.com/flex/mx"
		creationComplete="initApp()" currentState="PlayState" title="MittSnakeGameView">
	<s:layout>
		<s:VerticalLayout/>
	</s:layout>
	
	<fx:Script>
		<![CDATA[
			import flashx.textLayout.formats.Float;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.graphics.codec.JPEGEncoder;
			import mx.graphics.codec.PNGEncoder;
			
			import spark.core.SpriteVisualElement;
			
			private var direction:String = "up";
			private var previousDirection:String;
			private var speed:Number = 4;
			private var gameOver:Boolean = false;
			private var gameWidth:int;
			private var gameHeight:int;
			private var snake:ArrayCollection = new ArrayCollection();
			private var bodyLocationArray:ArrayCollection = new ArrayCollection();
			private var score:int = 0;
			private var startDelay:uint = 0;
			
//			private var moneyBagByteArray:ByteArray = new ByteArray();
//			
//			private var myLoader:Loader = new Loader();
//			
//			private var myEncoder:PNGEncoder = new PNGEncoder();
			
			protected function initApp():void
			{
				// init snake pit height and width
				//trace("width: " + this.width);
				//trace("height: " + this.height);
				//snakePit.height = this.height - navigation.height - ((this.height - navigation.height) % mittFace.width);
				//snakePit.width = this.width - this.width % mittFace.width;
				
				startDelay = 0;
				
				// constrain height and width of snake pit
				mittFace.x = 0;
				mittFace.y = 0;
				moneyBag.x = 0;
				moneyBag.y = 0;
				var startHeight:uint = snakePit.height;
				var startWidth:uint = snakePit.width;
				snakePit.maxHeight = startHeight;
				snakePit.maxWidth = startWidth;
				
				// set the game height/width
				gameWidth = snakePit.width;
				gameHeight = snakePit.height;

				// do some image optimization for the body part money bags
				moneyBag.cacheAsBitmapMatrix = moneyBag.transform.concatenatedMatrix;
				moneyBag.cacheAsBitmap = true;
				
				mittFace.cacheAsBitmapMatrix = mittFace.transform.concatenatedMatrix;
				mittFace.cacheAsBitmap = true;
				
				bodyPartImg.cacheAsBitmapMatrix = bodyPartImg.transform.concatenatedMatrix;
				bodyPartImg.cacheAsBitmap = true;
			
				// randomly place the mitt face and money bag
				var Low:int = 0;
				var HighY:int = (gameHeight - mittFace.height) / mittFace.width;
				var HighX:int = (gameWidth - mittFace.width) / mittFace.width;
				mittFace.y = Math.floor(Math.random()*(1+HighY-Low)+Low) * mittFace.width;
				mittFace.x = Math.floor(Math.random()*(1+HighX-Low)+Low) * mittFace.width;
				
				do {
					moneyBag.y = Math.floor(Math.random()*(1+HighY-Low)+Low) * mittFace.width;	
				} while (mittFace.y == moneyBag.y)
					
				moneyBag.x = Math.floor(Math.random()*(1+HighX-Low)+Low) * mittFace.width;				
				
				// start in random direction
				var rand:int = Math.floor(Math.random()*(1+4-1)+1);
				switch (rand){
					case 1:
						direction = "up";
						break;
					case 2:
						direction = "right";
						break;
					case 3:
						direction = "down";
						break;
					case 4:
						direction = "left";
						break;
				}
				
				stage.frameRate = speed;
//				stage.addEventListener(KeyboardEvent.KEY_DOWN, reportKeyDown);
				snake.addItem(mittFace);
				var imageLocArray:ArrayCollection = new ArrayCollection();
				imageLocArray.addItem(5000);
				imageLocArray.addItem(5000);
				bodyLocationArray.addItem(imageLocArray);

				mittFace.addEventListener(Event.ENTER_FRAME, onEnterFrame);
			}

			/* should add key listening for desktop use later */ 
//			protected function reportKeyDown(event:KeyboardEvent):void {
//				trace("KEY DOWN");
//				if(event.charCode == Keyboard.UP) {
//					direction = "up";
//				}
//				if(event.charCode == Keyboard.DOWN) {
//					direction = "down";
//				}
//				if(event.charCode == Keyboard.LEFT) {
//					direction = "left";
//				}
//				if(event.charCode == Keyboard.RIGHT) {
//					direction = "right";
//				}
//			}

			protected function onEnterFrame(event:Event):void {
				// wait a few frames before game starts
				if (startDelay < 3) {
					startDelay++;
					return;
				}
				
				// update the score label in the title bar
				scoreBar.text = "Net Worth: $" + score + " Million";
				
				// Save location of Mitt's face on enter frame
				var initMittFaceX:uint = mittFace.x;
				var initMittFaceY:uint = mittFace.y;
				
				// Save location of body tail so we know where to add new segments
				var initTailX:uint = getTailX();
				var initTailY:uint = getTailY();
				
				// Collision Flag
				var collision:Boolean = false;
				
				for each (var current:ArrayCollection in bodyLocationArray) {
					var x:Number = current.getItemAt(0) as Number;
					var y:Number = current.getItemAt(1) as Number;
					if(mittFace.x == x && mittFace.y == y) {
						collision = true;
						break;
					}
				}
				
				if(!collision) {
					switch (direction){
						case "up":
							if (mittFace.y - mittFace.height < 0 || (snake.length > 1 && previousDirection == "down")) {
								gameOver = true;
								break;
							}
							mittFace.y -= mittFace.height;
							break;
						case "right":
							if (mittFace.x + mittFace.width*2 > gameWidth || (snake.length > 1 && previousDirection == "left")) {
								gameOver = true;
								break;
							}
							mittFace.x += mittFace.width;
							break;
						case "down":
							if (mittFace.y + mittFace.height*2 > gameHeight || (snake.length > 1 && previousDirection == "up")) {	
								gameOver = true;
								break;
							}
							mittFace.y += mittFace.height;
							break;
						case "left":
							if (mittFace.x - mittFace.width < 0 || (snake.length > 1 && previousDirection == "right")) {	
								gameOver = true;
								break;
							}
							mittFace.x -= mittFace.width;
							break;
					}
				} else {
					gameOver = true;
				}
				
				// handle game over
				if (gameOver == true) {
					// set game over label
					gameOverLabel.text = "Game Over!\n" + 
						"Net Worth:  $" + score + " Million\n"+
						"Click to Play Again";
					// reset frame rate
					stage.frameRate = 32;
					// display game over state
					this.currentState = "GameOver";
					mittFace.removeEventListener(Event.ENTER_FRAME, onEnterFrame, false);
					return;
				}
								
				if(snake.length > 1) {
					moveBody(initMittFaceX, initMittFaceY, 0);
				}
				
				if (mittFace.y == moneyBag.y && mittFace.x == moneyBag.x) {
					addPartToBody(initTailX, initTailY);
					moveMoney();
					// update the score label in the title bar
					score += 1;
					scoreBar.text = "Net Worth: $" + score + " Million";
				}
			}
			
			protected function moveBody(moveToX:uint, moveToY:uint, index:uint):void {
				if(index >= snake.length - 1) {
					return;
				}
				else {
					var currentX:uint = (snake.getItemAt(index+1, 0) as Image).x;
					var currentY:uint = (snake.getItemAt(index+1, 0) as Image).y;
					(snake.getItemAt(index+1, 0) as Image).x = moveToX;
					(snake.getItemAt(index+1, 0) as Image).y = moveToY;
					var imageLocArray:ArrayCollection = new ArrayCollection();
					imageLocArray.addItem(moveToX);
					imageLocArray.addItem(moveToY);
					bodyLocationArray.setItemAt(imageLocArray, index+1);
					moveBody(currentX, currentY, index + 1); 
				}
			}
			
			protected function addPartToBody(tailX:uint, tailY:uint):void {				
				var buffer:BitmapData = new BitmapData ( bodyPartImg.width, bodyPartImg.height, true);
				buffer.draw(bodyPartImg);
				
				var bodyPartBitmap:Bitmap = new Bitmap(buffer);
				
				var bodyPart:Image = new Image();
				bodyPart.source = bodyPartBitmap;
				
				bodyPart.cacheAsBitmapMatrix = bodyPart.transform.concatenatedMatrix;
				bodyPart.cacheAsBitmap = true;
				
				bodyPart.height = 30;
				bodyPart.width = 30;
				bodyPart.x = tailX;
				bodyPart.y = tailY;
				
				snakePit.addElement(bodyPart);
				
				snake.addItem(bodyPart);
				
				var imageLocArray:ArrayCollection = new ArrayCollection();
				imageLocArray.addItem(bodyPart.x);
				imageLocArray.addItem(bodyPart.y);
				bodyLocationArray.addItem(imageLocArray);

			}
			
			protected function getTailX():uint {
				return snake.getItemAt(snake.length-1, 0).x;
			}
			
			protected function getTailY():uint {
				return snake.getItemAt(snake.length-1, 0).y;
			}
			
			protected function moveMoney():void 
			{
				var oldBagY:int = moneyBag.y;
				var Low:int = 0;
				var HighY:int = (gameHeight - mittFace.height) / mittFace.width;
				var HighX:int = (gameWidth- mittFace.width) / mittFace.width;
				var yLocArray:ArrayCollection = new ArrayCollection();

				for each (var current:ArrayCollection in bodyLocationArray) {
					var y:Number = current.getItemAt(1) as Number;
					yLocArray.addItem(y);
				}
				
				do {
					moneyBag.y = Math.floor(Math.random()*(1+HighY-Low)+Low) * mittFace.width;	
				} while (mittFace.y == moneyBag.y || moneyBag.y == oldBagY || yLocArray.contains(moneyBag.y))
				
				moneyBag.x = Math.floor(Math.random()*(1+HighX-Low)+Low) * mittFace.width;	
				// score += 1;
				
			}
			
			protected function upButton_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				previousDirection = direction;
				direction = "up";
			}
			
			protected function downButton_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				previousDirection = direction;
				direction = "down";
				
			}
			
			protected function leftButton_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				previousDirection = direction;
				direction = "left";
				
			}
			
			protected function rightButton_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				previousDirection = direction;
				direction = "right";
			}
			
			
		]]>
	</fx:Script>
	<s:states>
		<s:State name="PlayState"/>
		<s:State name="GameOver"/>
	</s:states>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<s:titleContent>
		<s:Label id="scoreBar" width="578" color="#FFFFFF" fontFamily="_sans" fontSize="22"
				 text="Net Worth: $0 Million" textAlign="left" verticalAlign="middle"
				 text.GameOver="Game Over"
				 width.PlayState="100%"/>
	</s:titleContent>
	
	<s:VGroup width="100%" height="100%" horizontalAlign="center">
		<s:Group id="snakePit" width="100%" height="90%"
				 height.GameOver="100%">
			<s:SWFLoader visible="true"  id="mittFace" width="30" height="30" includeIn="PlayState" x="0" y="0" 
						 depth="999" source="@Embed('assets/mittChomping.swf')"/>
			<!--<s:Image id="mittFace" includeIn="PlayState" x="107" y="36" width="30" height="30"
					 depth="999" source="@Embed('assets/mittFace.png')"/>-->
			<s:Image id="moneyBag" includeIn="PlayState" x="148" y="270" width="30" height="30"
					 source="@Embed('assets/moneyBag.png')"/>
			<s:Image visible="false" source="@Embed('assets/moneyBag.png')" id="bodyPartImg" />
			<!-- <shapes:MySquare x="100" y="100" id="square"/> -->
			<s:Label id="gameOverLabel" 
					 visible="false" 
					 width.PlayState="0" 
					 height.PlayState="0"
					 backgroundColor="#393939" 
					 color="#EFEFEF" depth="1000"
					 fontFamily="Courier New" 
					 fontSize="20" 
					 textAlign="center"
					 verticalAlign="middle"
					 visible.GameOver="true" 
					 width.GameOver="100%" 
					 height.GameOver="100%"
					 click="navigator.popView();navigator.pushView(MittSnakeGameView)"/>
		</s:Group>
		<s:TileGroup includeIn="PlayState" width="35%" horizontalAlign="center" paddingBottom="5"
					 requestedColumnCount="1" requestedRowCount="2" verticalAlign="middle">
			<s:Button id="upButton" width="70" label="Up" click="upButton_clickHandler(event)"/>
			<s:HGroup>
				<s:Button id="leftButton" width="70" label="Left"
						  click="leftButton_clickHandler(event)"/>
				<s:Button id="downButton" width="70" label="Down"
						  click="downButton_clickHandler(event)"/>
				<s:Button id="rightButton" width="70" label="Right"
						  click="rightButton_clickHandler(event)"/>
			</s:HGroup>	
		</s:TileGroup>
	</s:VGroup>
</s:View>
